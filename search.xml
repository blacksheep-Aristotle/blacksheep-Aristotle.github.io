<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>L-value and R-value and par and arg</title>
    <url>/2021/12/21/L-value-and-R-value/</url>
    <content><![CDATA[<h1 id="什么是左值和右值"><a href="#什么是左值和右值" class="headerlink" title="什么是左值和右值"></a>什么是左值和右值</h1><p>c++ primer plus：</p>
<p>变量和文字常量都有存储区，并且有相关的类型。区别在于变量是可寻址的（addressable）对于每一个变量都有两个值与其相联：</p>
<p>   1).它的数据值，存储在某个内存地址中。有时这个值也被称为对象的右值（rvalue,读做are-value）.我们也可认为右值的意思是被读取的值（read   value）。   文字常量和变量都可  被用作右值。   </p>
<p>   2).它的地址值——即存储数据值的那块内存的地址。它有时被称为变量的左值（lvalue，读作ell-value）。我们也可认为左值的意思是位置值location   value文字常量不能被用作左值。</p>
<p>简单来说左值就是存放在内存单元中（data段，roadata段。。。）的值，有实际存储地址，可以&amp;取地址的？</p>
<p>右值则不是内存单元中的值，不能对它&amp;取地址，可能存储在寄存器中，也可能是立即数或一个临时对象？</p>
<p>一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址（右值引用用于表达式中时会变为左值）。</p>
 <span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">int</span>&amp; i)</span>  <span class="comment">//左值表达式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;LValue processed: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_value</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span>  <span class="comment">//右值表达式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RValue processed: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">process_value</span>(a);</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; x=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">process_value</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">process_value</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LValue processed: <span class="number">0</span>                                                   RValue processed: <span class="number">1</span>                                                   LValue processed: <span class="number">2</span> </span><br></pre></td></tr></table></figure>

<p>再举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> num) :<span class="built_in">data</span>(num) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">get_data</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">get_data</span>() = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_data</span>() &lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">3</span></span><br><span class="line">明明没有对data赋值却改变了它，因为发生了左值引用！</span><br></pre></td></tr></table></figure>







<p>&lt;image-20211228002457592.png” alt=”image-20211228002457592” style=”zoom:80%;” /&gt;</p>
<h1 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h1><p><strong>注：</strong>形参和实参只是语法层面的概念</p>
<p>实参就是已经有内存空间，具体存在的参数。</p>
<p>形参相当于一个概念的声明，实质是“占位符”。函数运行时会把实参的值赋予给形参，如果是传值，那就相当于一次深拷贝,会在栈上临时复制一份对象。如果是传引用，只是复制一个指针指向对象的内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        a=b;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(x,y)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a，b是形参，告诉编译器这个函数的传值是int类型的。</span></span><br><span class="line"><span class="comment">//x，y是实参，分配了内存，具体存在的。</span></span><br></pre></td></tr></table></figure>



<h1 id="缺省值"><a href="#缺省值" class="headerlink" title="缺省值"></a>缺省值</h1><p>缺少，省略</p>
<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><p>move的本质就是帮助编译器选择重载函数, 告诉编译器”请尽量把此参数当做右值来处理”</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存</title>
    <url>/2021/12/20/c-%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="进程在内存中的存储形式"><a href="#进程在内存中的存储形式" class="headerlink" title="进程在内存中的存储形式"></a>进程在内存中的存储形式</h1><p><strong>什么是段</strong></p>
<p>一个程序经过编译后生成的文件里除了包含编译后的及机器指令代码，数据，还有所需的符号表，字符串等等等。这些信息就按照不同的属性存储在内存中。这就是段，一个一定长度的内存区域，存储着相同属性的数据。</p>
 <span id="more"></span>

<p><img src="/c-%E5%86%85%E5%AD%98/20201001165330730.png" alt="img"></p>
<p><img src="file://C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211206225747064.png?lastModify=1640250351" alt="image-20211206225747064"></p>
<p>linux下的内存分配：</p>
<p><img src="c-%E5%86%85%E5%AD%98/image-20211227214849510.png" alt="image-20211227214849510"></p>
<ul>
<li><p>FIle Header（文件头）</p>
<p>描述整个文件的属性：文件是否可执行，是静态链接还是动态链接及入口地址（重定位入口地址？），目标操作系统，硬件信息。。。文件头还保存了一个段表：描述文件中各个段的数组，存储了文件中各个段的所有信息（在文件中的偏移位置和段的属性等。。。）</p>
</li>
<li><p>Code Segment（代码区）</p>
<p>也称Text Segment，存放可执行程序的机器码（二进制代码）。</p>
</li>
<li><p>有时你也会看到 .rodata 这是常量数据区</p>
</li>
</ul>
<p>ro：read only。用来存放常量数据，字符串会被编译器自动放在rodata中，加 const 关键字的常量数据会被放在 rodata 中。</p>
<p>rodata的数据是多进程共享的，且其中数据不能被改变，提高了内存利用率。</p>
<ul>
<li>Data Segment (数据区）</li>
</ul>
<p>存放已初始化的<strong>全局和静态变量</strong>， 常量数据（如字符串常量）。初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。</p>
<ul>
<li> BSS（Block started by symbol)</li>
</ul>
<p>​    存放未初始化的全局和静态变量。（默认设为0）主要作用就是为未初始化的全局变量和局部静态变量预留位置。</p>
<p><em>而自由存储是C++中通过new和delete动态分配和释放对象的<strong>抽象概念</strong>，<strong>通过new来申请的内存区域可称为自由存储区</strong>。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但<strong>程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了</strong>。</em></p>
<ul>
<li>Heap（堆）</li>
</ul>
<p>从低地址向高地址增长（堆是向高地址扩展的数据结构，是<strong>不连续的内存区域</strong>。这是由于系统是<strong>用链表来存储的空闲内存地址</strong>的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2251612643%22%7D">虚拟内存</a>。）。容量大于栈，<strong>程序中动态分配的内存在此区域。就是那些由new分配的内存块</strong>，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>系统分配堆内存的过程：</p>
<p><strong>堆：</strong>首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>  会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从<a href="https://www.zhihu.com/search?q=%E7%A9%BA%E9%97%B2%E7%BB%93%E7%82%B9%E9%93%BE%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2251612643%22%7D">空闲结点链表</a><br>  中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块<a href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2251612643%22%7D">内存空间</a>中的<br>  首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。<br>  另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部<br>  分重新放入<a href="https://www.zhihu.com/search?q=%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2251612643%22%7D">空闲链表</a>中。</p>
<p> 调用 free 函数时，它将用户释放的内存块连接到空闲链表上。 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。</p>
<p><strong>Linux中对堆的管理</strong></p>
<p><img src="c-%E5%86%85%E5%AD%98/051536261875516.png" alt="Linux进程堆管理"></p>
<p><strong>Linux维护一个break指针，这个指针指向堆空间的某个地址。</strong>从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。</p>
<p>Linux通过brk和sbrk系统调用操作break指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span>* addr)</span></span>;   <span class="comment">//brk将break指针直接设置为某个地址,功时返回0，否则返回-1并设置errno为ENOMEM</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;   <span class="comment">//sbrk将break从当前位置移动increment所指定的增量。成功时返回break移动之前所指向的地址，否则返回(void *)-1。如果将increment设置为0，则可以获得当前break的地址。</span></span><br></pre></td></tr></table></figure>

<p>在堆区中， <strong>start_brk 指向 heap 的开始，而 brk 指向 heap 的顶部。</strong>可以使用系统调用 brk()和 sbrk()来增 加标识 heap 顶部的 brk 值，从而线性的增加分配给用户的 heap 空间。<strong>在使 malloc 之前，brk 的值等于 start_brk，也就是说 heap 大小为 0。</strong></p>
<p>mmap()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, size\<span class="keyword">_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off\<span class="keyword">_t</span> offset)</span></span>;     <span class="comment">//Mmap的第一种用法是映射此盘文件到内存中；第二种用法是匿名映射，不映射磁盘文件，而向映射区申请一块内存。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;  <span class="comment">//Munmap函数用于释放内存。</span></span><br></pre></td></tr></table></figure>

<p>当开辟的空间小于 128K 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)</p>
<p>当开辟的空间大于 128K 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。</p>
<p><img src="c-%E5%86%85%E5%AD%98/image-20211227213621395.png" alt="image-20211227213621395"></p>
<p>_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。<strong>也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</strong></p>
<p>当开辟的空间大于 128K 时，<strong>那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存</strong></p>
<p><strong>这样子做主要是因为:</strong></p>
<p>　　<strong>brk</strong>分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。</p>
<p><img src="c-%E5%86%85%E5%AD%98/image-20211227213949497.png" alt="image-20211227213949497"></p>
<p>进程调用free(B)以后，如图7所示</p>
<p>　　B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了</p>
<p>进程调用free(D)以后，如图8所示</p>
<p>　　B和D连接起来，变成一块140K的空闲内存　　</p>
<p>默认情况下：</p>
<p>　　<strong>当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。</strong>在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示</p>
<p><img src="c-%E5%86%85%E5%AD%98/image-20211227214137530.png" alt="image-20211227214137530"></p>
<p>（这部分我也找不到原作者是谁，如有知晓或侵权还请联系）</p>
<ul>
<li>Stack（栈）</li>
</ul>
<p>​    从高地址向低地址增长。由编译器自动管理分配。<strong>程序中的局部变量、函数参数值、返回变量等存在此区域。</strong>在执行函数时，<strong>函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。</strong>栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>   在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可<br>  执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈<br>  的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地<br>  址，也就是主函数中的下一条指令，程序由该点继续运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux下线程的默认栈大小是8m（Linux将高位1GB留给内核，低位3GB留给进程。）</span><br><span class="line">    可以用 ulimit -s 查看</span><br><span class="line">    查看单个进程暂用堆栈的信息 strace -f -p &#123;PID&#125;</span><br><span class="line">	临时改变栈空间的大小 ulimit -s 102400 # 改为100MB   ulimit -s ulimited # 不限制</span><br><span class="line">    永久修改栈空间大大小：</span><br><span class="line">        echo -ne </span><br><span class="line">		&quot;</span><br><span class="line">		* soft stack 102400    //栈空间大小默认为100MB</span><br><span class="line">		&quot; </span><br><span class="line"><span class="meta">		&gt;</span><span class="bash">&gt;/etc/security/limits.conf</span></span><br><span class="line">Windows下程序的栈大小是链接时决定的（Win32将低区的2GB留给进程使用， 高区的2GB则留给系统使用。）</span><br><span class="line">        link /stack 102400 ....  //程序默认单个线程的栈大小为1M</span><br><span class="line">注:windows32用户态空间大小是2GB,如果fork出线程数过多,导致进程的栈大小超过2GB,程序会崩溃</span><br><span class="line">    	</span><br></pre></td></tr></table></figure>

<p> 当调用函数时，一块连续内存(堆栈帧）压入栈；函数返回时，堆栈帧弹出。</p>
<p>   堆栈帧包含如下数据:</p>
<p>   ① 函数返回地址</p>
<p>   ② 局部变量/CPU寄存器数据备份</p>
<p><img src="c-%E5%86%85%E5%AD%98/20201004125637216.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; &#125;  <span class="comment">//在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存（如果没有对new重载，new是通过调用malloc开辟空间的），然后返回这块内存的首地址，放入栈中。执行对应类型的构造函数。</span></span><br><span class="line"></span><br><span class="line">汇编：</span><br><span class="line"><span class="number">00401028</span> push <span class="number">14</span>h						<span class="comment">//堆上分配的内存大小</span></span><br><span class="line"><span class="number">0040102</span><span class="function">A call <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="number">00401060</span>)</span>   <span class="comment">//分配的内存的地址</span></span></span><br><span class="line"><span class="function">0040102F add esp,4</span></span><br><span class="line"><span class="function">00401032 mov dword ptr [ebp-8],eax</span></span><br><span class="line"><span class="function">00401035 mov eax,dword ptr [ebp-8]</span></span><br><span class="line"><span class="function">00401038 mov dword ptr [ebp-4],eax     <span class="comment">//返回这块内存的首地址</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span>   </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span>   a   =   <span class="number">1</span>;    </span><br><span class="line">  <span class="keyword">char</span>   c[]   =   <span class="string">&quot;1234567890&quot;</span>;    <span class="comment">//栈</span></span><br><span class="line">  <span class="keyword">char</span>   *p   =<span class="string">&quot;1234567890&quot;</span>;    <span class="comment">//堆</span></span><br><span class="line">  a   =   c[<span class="number">1</span>];    </span><br><span class="line">  a   =   p[<span class="number">1</span>];    </span><br><span class="line">  <span class="keyword">return</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">  对应的汇编代码    </span><br><span class="line">  <span class="number">10</span>:   a   =   c[<span class="number">1</span>];    </span><br><span class="line">  <span class="number">00401067</span>   <span class="number">8</span>A   <span class="number">4</span>D   F1   mov   cl,byte   ptr   [ebp<span class="number">-0F</span>h]    </span><br><span class="line">  <span class="number">0040106</span>A   <span class="number">88</span>   <span class="number">4</span>D   FC   mov   byte   ptr   [ebp<span class="number">-4</span>],cl    </span><br><span class="line">  <span class="number">11</span>:   a   =   p[<span class="number">1</span>];    </span><br><span class="line">  <span class="number">0040106</span>D   <span class="number">8B</span>   <span class="number">55</span>   EC   mov   edx,dword   ptr   [ebp<span class="number">-14</span>h]    </span><br><span class="line">  <span class="number">00401070</span>   <span class="number">8</span>A   <span class="number">42</span>   <span class="number">01</span>   mov   al,byte   ptr   [edx+<span class="number">1</span>]    </span><br><span class="line">  <span class="number">00401073</span>   <span class="number">88</span>   <span class="number">45</span>   FC   mov   byte   ptr   [ebp<span class="number">-4</span>],al</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//全局初始化区 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p1;<span class="comment">//   全局未初始化区    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span>   b;<span class="comment">//   栈    </span></span><br><span class="line">  <span class="keyword">char</span>   s[]   =   <span class="string">&quot;abc&quot;</span>;<span class="comment">//   栈    </span></span><br><span class="line">  <span class="keyword">char</span>   *p2;<span class="comment">//   栈    </span></span><br><span class="line">  <span class="keyword">char</span>   *p3   =   <span class="string">&quot;123456&quot;</span>;<span class="comment">//   123456/0在常量区，p3在栈上。    </span></span><br><span class="line">  <span class="keyword">static</span>   <span class="keyword">int</span>   c   =<span class="number">0</span>;<span class="comment">//   全局（静态）初始化区    </span></span><br><span class="line">  p1   =   (<span class="keyword">char</span>   *)<span class="built_in">malloc</span>(<span class="number">10</span>);    </span><br><span class="line">  p2   =   (<span class="keyword">char</span>   *)<span class="built_in">malloc</span>(<span class="number">20</span>);    </span><br><span class="line">  <span class="comment">//分配得来得10和20字节的区域就在堆区。    </span></span><br><span class="line">  <span class="built_in">strcpy</span>(p1,   <span class="string">&quot;123456&quot;</span>);<span class="comment">//   123456/0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot; 优化成一个地方。       </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h1><p>流是一种数据结构，封装了一组有序的数据元素。用户可以对流进行数据读写。</p>
<p>输出流：允许数据流用户插入元素，但不能读取。</p>
<p>输入流：允许用户提取元素，但不能写入。</p>
<p>一个流可以同时作为输入输出流。</p>
<p>一般情况下，流是作为其他数据结构或资源的接口：例子：文件输出流，封装一个打开准备写的文件，提供顺序存储不同类型数据到磁盘的简单方法。</p>
<h1 id="malloc和move"><a href="#malloc和move" class="headerlink" title="malloc和move"></a>malloc和move</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">int</span>* ptr=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)&#123;   <span class="comment">//如果分配失败，会返回空指针。</span></span><br><span class="line">    cout&lt;&lt;“内存分配失败”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。 </span><br><span class="line">如果开辟成功，则返回一个指向开辟好空间的指针<span class="keyword">size_t</span> size表示开辟几个字节大小的空间如果开辟失败，则返回一个<span class="literal">NULL</span>指针，因此malloc的返回值一定要做检查。 </span><br><span class="line">返回值的类型是 <span class="keyword">void</span>* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。如果参数 size为<span class="number">0</span>，malloc的行为是标准是未定义的，取决于编译器。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>; <span class="comment">//free要和malloc配套使用</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">//free只负责释放空间！所以在free之后要手动的改变指针。</span></span><br><span class="line">-ptr 传过来的是开辟空间的起始地址， 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的,如果为空指针什么也不会发生如果参数 ptr 是<span class="literal">NULL</span>指针，则函数什么事都不做。 </span><br><span class="line">free只是释放空间，对于指针并不会改变！！！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>常见的错误</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *P=<span class="literal">NULL</span>;</span><br><span class="line">    p=<span class="built_in">mem</span>(p);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>!程序奔溃了！！</strong></p>
<p>因为如果要改变指针的值，你要给函数传递指针的指针。</p>
<p>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem</span><span class="params">(<span class="keyword">char</span>** p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  <span class="comment">//malloc记得判断NULL</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;wrong1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mem</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pp=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span>(pp==<span class="literal">NULL</span>)  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;wrong2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">char</span> **p=&amp;pp;</span><br><span class="line">    **p=<span class="number">40</span>;</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mem</span><span class="params">(<span class="keyword">int</span> size_)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size_*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;wrong3&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">mem</span>(&amp;p);</span><br><span class="line">    <span class="keyword">char</span> *p1=<span class="built_in">mem</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;hello world again&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%s&quot;</span>, p,p1);</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//分配完记得释放。</span></span><br><span class="line">    p=<span class="literal">NULL</span>;  <span class="comment">//释放完记得指针置空</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    p1=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="c-%E5%86%85%E5%AD%98/image-20211227205257592.png" alt="image-20211227205257592"></p>
<h2 id="malloc底层实现"><a href="#malloc底层实现" class="headerlink" title="malloc底层实现"></a>malloc底层实现</h2><p><strong>linux下的内存池实现</strong></p>
<p>new和malloc的区别</p>
<p><img src="c-%E5%86%85%E5%AD%98/v2-96cc379298a4cff245a62ebf3e41f961_1440w.jpg" alt="img"></p>
<p>因为brk、sbrk、mmap都属于系统调用，若每次申请内存，都调用这三个，那么每次都会产生系统调用，影响性能；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果高地址的内存没有被释放，低地址的内存就不能被回收。</p>
<p>所以malloc采用的是内存池的管理方式（ptmalloc），Ptmalloc 采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。为了内存分配函数malloc的高效性，ptmalloc会预先向操作系统申请一块内存供用户使用，当我们申请和释放内存的时候，ptmalloc会将这些内存管理起来，并通过一些策略来判断是否将其回收给操作系统。这样做的最大好处就是，使用户申请和释放内存的时候更加高效，避免产生过多的内存碎片。</p>
<h3 id="内存分配malloc流程"><a href="#内存分配malloc流程" class="headerlink" title="内存分配malloc流程"></a>内存分配malloc流程</h3><ol>
<li>获取分配区的锁，防止多线程冲突。</li>
<li>计算出实际需要分配的内存的chunk实际大小。</li>
<li>判断chunk的大小，如果小于max_fast（64Ｂ），则尝试去fast bins上取适合的chunk，如果有则分配结束。否则，下一步；</li>
<li>判断chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。否则下一步；</li>
<li>ptmalloc首先会遍历fast bins中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中然后遍历 unsorted bins。如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins；如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除；如果unsorted bins中的某一chunk大小 属于small bins的范围，则放入small bins的头部；如果unsorted bins中的某一chunk大小 属于large bins的范围，则找到合适的位置放入。若未分配成功，转入下一步；</li>
<li>从large bins中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入unsorted bin中。</li>
<li>如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了,当top chunk大小比用户所请求大小还大的时候，top chunk会分为两个部分：User chunk（用户请求大小）和Remainder chunk（剩余大小）。其中Remainder chunk成为新的top chunk。当top chunk大小小于用户所请求的大小时，top chunk就通过sbrk（main arena）或mmap（thread arena）系统调用来扩容。</li>
<li>到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如 果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在 这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。</li>
<li>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配 一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初 始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切 割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
<p>简而言之： 获取分配区(arena)并加锁–&gt; fast bin –&gt; unsorted bin –&gt; small bin –&gt; large bin –&gt; top chunk –&gt; 扩展堆</p>
<h3 id="内存回收流程"><a href="#内存回收流程" class="headerlink" title="内存回收流程"></a>内存回收流程</h3><ol>
<li>获取分配区的锁，保证线程安全。</li>
<li>如果free的是空指针，则返回，什么都不做。</li>
<li>判断当前chunk是否是mmap映射区域映射的内存，如果是，则直接munmap()释放这块内存。前面的已使用chunk的数据结构中，我们可以看到有M来标识是否是mmap映射的内存。</li>
<li>判断chunk是否与top chunk相邻，如果相邻，则直接和top chunk合并（和top chunk相邻相当于和分配区中的空闲内存块相邻）。转到步骤8</li>
<li>如果chunk的大小大于max_fast（64b），则放入unsorted bin，并且检查是否有合并，有合并情况并且和top chunk相邻，则转到步骤8；没有合并情况则free。</li>
<li>如果chunk的大小小于 max_fast（64b），则直接放入fast bin，fast bin并没有改变chunk的状态。没有合并情况，则free；有合并情况，转到步骤7</li>
<li>在fast bin，如果当前chunk的下一个chunk也是空闲的，则将这两个chunk合并，放入unsorted bin上面。合并后的大小如果大于64B，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的空闲chunk进行合并，合并后的chunk会被放到unsorted bin中，fast bin会变为空。合并后的chunk和topchunk相邻，则会合并到topchunk中。转到步骤8</li>
<li>判断top chunk的大小是否大于mmap收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还top chunk中的一部分给操作系统。free结束。</li>
</ol>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>为了避免Glibc内存暴增，需要注意：</p>
<ol>
<li><p> 后分配的内存先释放，因为ptmalloc收缩内存是从top chunk开始，如果与top chunk相邻的chunk不能释放，top chunk以下的chunk都无法释放。</p>
</li>
<li><p>Ptmalloc不适合用于管理长生命周期的内存，特别是持续不定期分配和释放长生命周期的内存，这将导致ptmalloc内存暴增。</p>
</li>
<li><p>不要关闭 ptmalloc 的 mmap 分配阈值动态调整机制，因为这种机制保证了短生命周期的 内存分配尽量从 ptmalloc 缓存的内存 chunk 中分配，更高效，浪费更少的内存。</p>
</li>
<li><p>多线程分阶段执行的程序不适合用ptmalloc，这种程序的内存更适合用内存池管理</p>
</li>
<li><p>尽量减少程序的线程数量和避免频繁分配/释放内存。频繁分配，会导致锁的竞争，最终导致非主分配区增加，内存碎片增高，并且性能降低。</p>
</li>
<li><p>防止内存泄露，ptmalloc对内存泄露是相当敏感的，根据它的内存收缩机制，如果与top chunk相邻的那个chunk没有回收，将导致top chunk一下很多的空闲内存都无法返回给操作系统。</p>
</li>
<li><p>防止程序分配过多的内存，或是由于glibc内存暴增，导致系统内存耗尽，程序因为OOM被系统杀掉。预估程序可以使用的最大物理内存的大小，配置系统的/proc/sys/vm/overcommit_memory ,/proc/sys/vm/overcommit_ratio,以及使用ulimit -v限制程序能使用的虚拟内存的大小，防止程序因OOM被杀死掉。</p>
</li>
</ol>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p><strong>传统的分配内存：</strong></p>
<p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。<strong>并且因为申请的内存块大小不定，频繁申请释放时会造成大量的内存碎片。</strong></p>
<p><strong>内存池的分类</strong></p>
<p>应用程序自定义的内存池根据不同的适用场景又有不同的类型。从线程安全的角度来分，内存池可以分为单线程内存池和多线程内存池。</p>
<ul>
<li>单线程内存池整个生命周期只被一个线程使用，因而不需要考虑互斥访问的问题；</li>
<li>多线程内存池有可能被多个线程共享，因此则需要在每次分配和释放内存时加锁。相对而言，单线程内存池性能更高，而多线程内存池适用范围更广。</li>
</ul>
<h1 id="vector…-stl"><a href="#vector…-stl" class="headerlink" title="vector…..stl"></a>vector…..stl</h1>]]></content>
      <categories>
        <category>interior</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++多线程简要</title>
    <url>/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/</url>
    <content><![CDATA[<p>读muduo总结（本文许多例子引用自Linux多线程服务端编程），推荐方向是linux或后端的同学读一读此书）</p>
<h1 id="多线程下的对象安全"><a href="#多线程下的对象安全" class="headerlink" title="多线程下的对象安全"></a>多线程下的对象安全</h1><p>因为c++中要求程序员自己管理对象的生命周期，而在多线程环境下，一个对象可能被多个线程看到/操作，如何保证对象的安全显得尤为困难。</p>
<p>即如何保证对象的安全性，顺序性，存在性</p>
 <span id="more"></span>

<ul>
<li>如何保证不会因为交叉的操作而造成死锁？</li>
</ul>
<p>例：</p>
<ul>
<li>如何保证对象的操作是符合设定顺序的：a++ a– 不会执行成a– a++</li>
</ul>
<ul>
<li>如何保证操作的对象是存在的？如何保证销毁对象时对象不会被其他线程引用？</li>
</ul>
<p>这里引用陈硕的例子：</p>
<p>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行 该对象的成员函数？ </p>
<p>如何保证在执行成员函数期间，对象不会在另一个线程被析构？ </p>
<p>在调用某个对象的成员函数之前，如何得知这个对象还活着？它 的析构函数会不会碰巧执行到一半？</p>
<p>所以当你在多线程环境中编写对象时，请在下手时多思考思考：我怎么保证对象的安全性，顺序性，存在性？</p>
<p><strong>依据[JCP]，一个线程安全的class应当满足以下三个条件：</strong> </p>
<ul>
<li>多个线程同时访问时，其表现出正确的行为。 </li>
<li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何 交织（interleaving）。 </li>
<li>调用端代码无须额外的同步或其他协调动作。</li>
</ul>
<p><strong>c++标准库中的线程安全</strong></p>
<p>以下线程安全规则应用到标准 C++ 库中的所有类，这也包括 <code>shared_ptr</code>，如下所述。 有时提供更强的保证（例如，如下所述的标准 iostream 对象）和用于多线程的类型，如中所述<atomic>。</p>
<ul>
<li><p>从多个线程读取某个对象时，该对象是线程安全的。 例如，给定对象 A，可安全地同时从线程 1 和线程 2 读取 A。</p>
</li>
<li><p>如果要通过某个线程写入到对象，则必须保护相同线程或其他线程上所有对该对象的读取和写入。 例如，给定对象 A，如果线程 1 将写入到 A，则必须阻止线程 2 读取或写入 A。</p>
</li>
<li><p>即使另一个线程正在读取或写入同一类型的不同实例，也可以安全地读取和写入某个类型的实例。 例如，如果给定的对象 A 和 B 属于同一类型，则在线程1中写入时是安全的，并且在线程2中读取 B。</p>
</li>
</ul>
<h2 id="在对象构造时保证存在性"><a href="#在对象构造时保证存在性" class="headerlink" title="在对象构造时保证存在性"></a>在对象构造时保证存在性</h2><p>对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this 指针，即 </p>
<ul>
<li>不要在构造函数中注册任何回调； </li>
<li>也不要在构造函数中把this传给跨线程的对象； </li>
<li>即便在构造函数的最后一行也不行。</li>
</ul>
<p>之所以这样规定，是因为在构造函数执行期间对象还没有完成初始 化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除 外），那么别的线程有可能访问这个半成品对象。（对象的存在性无法保证）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">Foo</span>();  <span class="comment">//尽量不要在构造函数里出现this和回调函数，当需要注册回调函数时可以再定义一个函数用来实现所需功能</span></span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">observer</span><span class="params">(Observable* s)</span></span>&#123;</span><br><span class="line">		s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo* foo =<span class="keyword">new</span> Foo;</span><br><span class="line">Observable* s=<span class="built_in">getSubject</span>();</span><br><span class="line">foo-&gt;<span class="built_in">register_</span>(s);<span class="comment">// 二段式构造</span></span><br></pre></td></tr></table></figure>



<h3 id="析构对象时的线程安全"><a href="#析构对象时的线程安全" class="headerlink" title="析构对象时的线程安全"></a>析构对象时的线程安全</h3><p>在析构对象时保证线程安全，那用互斥锁不就好了吗？要销毁的时候加锁，然后析构，这样只有一个线程在析构，且其他线程现在无法访问这个对象，不就保证了对象的存在性和安全性了吗？</p>
<p><strong>但是用互斥锁来保证安全，那其成员函数用来保护临界区的互斥器本身就必须是有效的。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉！！！！</strong></p>
<p><img src="image-20211220205140600.png"></p>
<p>尽管线程A在销毁对象之后把指针置为了NULL，尽管线程B在调用x的 成员函数之前检查了指针x的值，但还是无法避免一种race condition： </p>
<p>1．线程A执行到了析构函数的(1)处，已经持有了互斥锁，即将继 续往下执行。 2．线程B通过了if (x)检测，阻塞在(2)处。</p>
<p>接下来会发生什么，只有天晓得。因为析构函数会把mutex_销毁， 那么(2)处有可能永远阻塞下去，有可能进入“临界区”，然后core dump，或者发生其他更糟糕的情况。 这个例子至少说明delete对象之后把指针置为NULL根本没用，如果 一个程序要靠这个来防止二次释放，说明代码逻辑出了问题。</p>
<p>这是可能有人会说了：既然互斥锁无法保证存在性，那我在操作对象的时候判断对象是否存在不就解决问题了吗？</p>
<p>很好，现在我们用指针来指向对象，用指针来判断对象是否存在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo *f=f1;</span><br><span class="line"><span class="keyword">if</span>(f)&#123;	<span class="comment">//存在？</span></span><br><span class="line">	f-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，用指针真的能判断对象是否存在吗？<strong>在Java中，一个reference只要不为null，它一定指向有效的对象。但是在c++中要知道，指针就只是指向了块内存而已，如果内存上的对象销毁了，你根本就访问不了它！</strong>直接erro了，更何况万一原址又创建了一个新的对象呢？再万一这个新的对象的类型 异于老的对象呢？</p>
<h3 id="用智能指针来解决存在性"><a href="#用智能指针来解决存在性" class="headerlink" title="用智能指针来解决存在性"></a>用智能指针来解决存在性</h3><p>**tips:**虽然智能指针好处很多，但设计绝大部分API的时候不应该出现智能指针，因为绝大多数API都不是操作所有权的API，而只是解引用访问被指向的对象，这时候正确的方式是使用裸指针裸引用，明确“无所有权”语义。</p>
<p><strong>shared_ptr控制对象的生命期。</strong>shared_ptr是<strong>强引用</strong>（想象成用铁丝 绑住堆上的对象），只要有一个指向x对象的shared_ptr存在，该x对象 就不会析构。当指向对象x的<strong>最后一个shared_ptr析构</strong>或reset()的时候，x 保证会被销毁。</p>
<p>std::shared_ptr 其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。（注意boost::bind 和容器的拷贝shared_ptr都有可能使引用值+1。）</p>
<p><strong>std::weak_ptr 要与 std::shared_ptr 一起使用。</strong> 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p>
<ol>
<li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li>
<li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li>
</ol>
<h4 id="智能指针的好处"><a href="#智能指针的好处" class="headerlink" title="智能指针的好处"></a>智能指针的好处</h4><ul>
<li>1．缓冲区溢出：用std::vector/std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是 裸指针来修改缓冲区。 </li>
<li>2．空悬指针／野指针：用shared_ptr/weak_ptr。 </li>
<li>3．重复释放：用scoped_ptr，只在对象析构的时候释放一次。 </li>
<li>4．内存泄漏：用scoped_ptr，对象析构的时候自动释放内存。 </li>
<li>5．不配对的new[]/delete：把new[]统统替换为 std::vector/scoped_array。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span>  // <span class="title">not</span> 100% <span class="title">thread</span> <span class="title">safe</span>!</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(weak_ptr&lt;Observer&gt; x)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(weak_ptr&lt;Observer&gt; x)</span></span>;  <span class="comment">// 可用 std::remove/vector::erase 实现</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator it = observers_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it != observers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="function">shared_ptr&lt;Observer&gt; <span class="title">obj</span><span class="params">(it-&gt;lock())</span></span>;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用次数+1</span></span><br><span class="line"></span><br><span class="line">        obj-&gt;<span class="built_in">update</span>();  <span class="comment">// 没有竞态条件，因为 obj 在栈上，对象不可能在本作用域内销毁</span></span><br><span class="line"></span><br><span class="line">        ++it;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象已经销毁，从容器中拿掉 weak_ptr</span></span><br><span class="line"></span><br><span class="line">        it = observers_.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  std::vector&lt;weak_ptr&lt;Observer&gt; &gt; observers_;  <span class="comment">// 如果把weak换成shared那Observer的生命周期会被延长，直至Observable析构或者调用unregister，因为容器的拷贝也会使引用值+1！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> Mutex mutex_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>尽量使一个对象只能被一个线程看见和操作，这样对象的构造和析构都在一个线程内完成，多线程下的对象安全就变成了单线程下的对象安全，任务简单不少。</p>
<p>如果真要使一个对象被多个线程操作，请使用智能指针来保证对象的存在性，且对象的构造和析构尽量由相同线程执行。在使用锁的时候尽量缩短临界区来提高安全性。</p>
<h2 id="如何保证对象的安全性与顺序性"><a href="#如何保证对象的安全性与顺序性" class="headerlink" title="如何保证对象的安全性与顺序性"></a>如何保证对象的安全性与顺序性</h2><p>前言</p>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p><strong>线程使用注意事项和线程安全（可重入函数）</strong></p>
<ul>
<li>1．首要原则是尽量最低限度地共享对象，减少需要同步的场合。 一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分 保护它。</li>
<li>2．其次是使用高级的并发编程构件，如TaskQueue、ProducerConsumer Queue、CountDownLatch等等。 </li>
<li>3．最后不得已必须使用底层同步原语（primitives）时，只用非递 归的互斥器和条件变量，慎用读写锁，不要用信号量。 </li>
<li>4．除了使用atomic整数之外，不自己编写lock-free代码，也不要 用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs. mutex。</li>
</ul>
<p>​                                                                    ——————————陈硕</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><strong>什么是锁？</strong></p>
<p><strong>为什么一个线程拿到了锁，另一个线程企图去对这个锁进行Lock操作时，为什么会阻塞？</strong> </p>
<p><strong>锁，其实就是一个标志，0表示解锁1表示加锁，锁争用就是多个线程争着把标志变成1，当一个标志为1其他线程会自旋的访问它直到变成0再根据某种调度策略把标志的修改权限赋予某个线程。</strong></p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222211943772.png" alt="image-20211222211943772"></p>
<p>虽然这部分操作是原子的，但是如果多个线程一直自旋访问标志无疑会造成极大的资源浪费。如果线程进行这种比较和交换并且它失败了，它不会再旋转，而是进入睡眠状态，并在标志的值发生变化时恢复它，再开始自旋，重复上面的过程直到它获得了这个锁。</p>
<p><strong>Linux下就是用futex来实现上诉功能的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We&#x27;re going to extend our flag variable to be able to take on another value, so, zero if tasks Q is free, one if it&#x27;s locked, and two if there is a thread waiting on the value of flag to change. Here in our reader, we do the atomic compare-and-swap. Assume it fails, here first we&#x27;re going to change flag to be two to indicate that the thread is going to sleep, and then we issue the futex system call to tell the kernel to put us to sleep, to suspend us, to tell the kernel, &quot;We want to be woken up once the value of flag changes.&quot; The kernel takes care of that part, and then once we&#x27;re resumed, we&#x27;re going to try and compare and swap again.</span><br><span class="line"></span><br><span class="line">Switching to kernel land, let&#x27;s see what the kernel does. The kernel needs to do two things. The first thing is, it needs to store away this information that we have T1 waiting on the flag variable so it can be resumed in the future. The way the Linux kernel does this is, we generate a key from the user space address - we need to do this because we&#x27;re in the kernel now. This is stored away in a wait queue entry that stores the thread and the key. If we had one wait queue per user space address, that sounds incredibly wasteful. What actually happens is - we use a hash table - the key is hashed, and we have a wait queue per hash bucket. What this means is, you can have two user space addresses that hash to the same hash bucket, and those entries would be stored in the same wait queue. Not a problem because the entries store the key as well.</span><br><span class="line"></span><br><span class="line">Now that we&#x27;ve stored away this information, to resume the thread later, we can put the thread to sleep. This is what the kernel does, it deschedules the calling thread. On the writer side, say the writer comes along, it finishes what it&#x27;s doing, it&#x27;s going to set the flag to unlocked, and then it&#x27;s going to issue a futex system call to tell the kernel to wake up a thread that was waiting on flag. The kernel does its thing, it finds the right hash bucket, it walks the wait queue, and it wakes up the first thread that was waiting on flag.</span><br></pre></td></tr></table></figure>

<p><a href="https://www.infoq.com/presentations/go-locks/">————让我们来谈谈锁    go中轻量锁的实现！ (infoq.com)</a></p>
<p>简而言之，就是线程在用户态争抢一块内存（一个指定的变量），如果抢不到，就自旋n次，还是没抢到，调用futex_wait进入内核态，去把自己挂起+排队（跟这个锁相关的队列），等着被释放锁的线程futex_wake（从内核态转用户态）。</p>
<p><strong>回到问题：</strong></p>
<ul>
<li><strong>一个线程拿到了锁，另一个线程企图去对这个锁进行Lock操作时，为什么会阻塞？</strong> </li>
</ul>
<p>这里的阻塞其实就是睡眠了，当线程一直抢不到锁时，操作系统会让他强制休眠，直到锁被释放再将他唤醒。</p>
<p><strong>使用非递归的互斥锁，不使用读写锁。</strong></p>
<p>使用非递归的原因是非递归和递归的性能差别不大，但是非递归能帮助我们在发现erro后更方便的找到错误原因（想象一下这个画面，一个递归锁被多个线程反复调用最终发生了死锁，你要怎么找到是哪个线程哪一步造成的原因呢）。</p>
<p>如果使用非递归锁，那么<strong>一个线程</strong>不能对同一个锁重复加锁，否则立即发生死锁。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span>&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    f-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line">test中加了锁，但是print又加了锁，非递归锁不能被一个线程重复加锁，所以立刻造成了死锁</span><br></pre></td></tr></table></figure>

<p>如果并不清楚这个函数是否会在已加锁的情况下调用，有以下几个解决方法：</p>
<ul>
<li>使用Linux已封装的lock_gurad()</li>
</ul>
<p>lock_gurad（）是Linux已经封装好的RAII思想的lock（），会在创建的时候加锁，销毁的时候自动解锁。</p>
<p>lock_gurad（）有个参数std::adopt_lock，收养锁，adopt_guard为结构体对象，表明当前线程已经获得了锁，不需要再锁了，此后mutex对象的解锁操作交由 lock_guard 对象 guard 来管理，在 guard 的生命周期结束之后，mutex对象会自动解锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">my_guard</span><span class="params">(my_mutex,std::adopt_lock)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span>&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">my_guard</span><span class="params">(my_mutex,std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    f-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：一般都是使用自己封装的lock_guard，并且lock_gurad（）锁的粒度可能很大，而且用adopt_lock的<strong>前提条件</strong>是要先给互斥量加锁，然后在后面的语句中不会再次lock()</p>
<ul>
<li>再创建一个相同的函数withlock用于加锁的场景，原来的函数用于不加锁的场景</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span>&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printwithlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    f-&gt;<span class="built_in">printwithlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重载函数，如果使用了锁，就用不加锁的那一个</li>
</ul>
<p><strong>还有一种常见的死锁场景是锁的交叉使用</strong></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap1</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutexa);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">lock</span>(mutexb);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap2</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="built_in">lock</span>(mutexb);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">lock</span>(mutexa);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时一个线程A执行swap1，另一个线程B执行swap2.</p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222164757247.png" alt="image-20211222164757247"></p>
<p>这两个线程因为永远等不到所需的锁，所以造成了死锁卡住了。一般来说多线程造成死锁的原因就是锁的交叉死锁，造成了你有我的锁，我有你的锁，成了个死循环。</p>
<p>这种死锁解决较为简单，因为调用顺序明了，不涉及内存的读写，只要养成在执行的时候按顺序加锁解锁的习惯就解决了。</p>
<p>这里再用陈硕的例子—–一个不易察觉的死锁：</p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222165207047.png" alt="image-20211222165207047"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::printall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">lockguard <span class="title">lock</span><span class="params">(Lmutex_)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f:requests_.<span class="built_in">end</span>())&#123;</span><br><span class="line">		f-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Request::print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">lockgurad <span class="title">lock</span><span class="params">(Rmutex_)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Request::process</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockgurad <span class="title">lock</span><span class="params">(Rmutex_)</span></span>;</span><br><span class="line">    inventory_.<span class="built_in">add</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::add</span><span class="params">(Request* req)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockgurad <span class="title">lock</span><span class="params">(Imutex_)</span></span>;</span><br><span class="line">    requests_.<span class="built_in">insert</span>(req);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Request</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">lockguard <span class="title">lock</span><span class="params">(Rmutex_)</span></span>;</span><br><span class="line">    inventory_.<span class="built_in">remove</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::remove</span><span class="params">(Request* req)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockguard <span class="title">lock</span><span class="params">(Lmutex_)</span></span>;</span><br><span class="line">    requests_.<span class="built_in">earse</span>(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看好像挺安全的，但是当req析构，inv刚好print（）刚加进去的req时：</p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222170900205.png" alt="image-20211222170900205"></p>
<p><strong>！！死锁了，这就是经典的read-and-write死锁</strong></p>
<p>解决的方法就是copy-and-write：在副本上读，在副本上写！不直接对源成员改变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::printall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Requestlist restcopy_;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">lockguard <span class="title">lock</span><span class="params">(Lmutex_)</span></span>;</span><br><span class="line">        restcopy_=requests_;	<span class="comment">//copy，复制副本</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f:restcopy_)&#123;		<span class="comment">//对副本读</span></span><br><span class="line">		f-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222202030478.png" alt="image-20211222202030478"></p>
<p>因为锁L的临界区很短，可以说只与它自己有关，L的释放不再被其他锁约束。所以remove（）一定会获得锁L！也就不会造成死锁了。</p>
<p>但是这又引出了新的问题，一是深拷贝的开销太大，二是仍有可能执行一个不存在的print（）。为了改进这两点，给出第二种方法。</p>
<ul>
<li>使用智能指针管理restes_</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">set&lt;std::weak_ptr&lt;Request&gt; rptr&gt; requests_;  </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">set&lt;Request*&gt; requests;</span><br><span class="line">shared_ptr&lt;requests&gt; requests_ptr;</span><br><span class="line">requests_ptr requests_;</span><br><span class="line"><span class="comment">//以下给方法二的写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::printall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requests_ptr req_ptrcopy;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">lockgurad <span class="title">lock</span><span class="params">(Imutex_)</span></span>;</span><br><span class="line">        req_ptrcopy=requests_;   <span class="comment">//shared_ptr引用+1</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f:restcopy_)&#123;		<span class="comment">//对副本读</span></span><br><span class="line">		f-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::add</span><span class="params">(Request* req)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockgurad <span class="title">lock</span><span class="params">(Imutex_)</span></span>;</span><br><span class="line">   	<span class="keyword">if</span>(!requests_.<span class="built_in">unique</span>())  <span class="comment">//对象正在被读</span></span><br><span class="line">    &#123;</span><br><span class="line">        requests_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">requests_ptr</span>(*requests_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(requests_.<span class="built_in">unique</span>());</span><br><span class="line">    requests_.<span class="built_in">insert</span>(req);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::remove</span><span class="params">(Request* req)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">LockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!requests_.<span class="built_in">unique</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      requests_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">requests_ptr</span>(*requests_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(requests_.<span class="built_in">unique</span>());</span><br><span class="line">    requests_-&gt;<span class="built_in">erase</span>(req);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<p>tips：不要同时读写，读/写前检查一下。<br>          不管读写，都要对shared_ptr加锁。<br>          写的copy一定要放在临界区内。<br>           写时，可以先加锁拷贝变量副本，然后修改变量副本。读时，可以先临界区拷贝变量到函数局部变量，再操作函数局部变量来避免死锁。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用信号量和条件变量来实现同步，注：对于wait端：条件变量得配合锁来使用。</p>
<ul>
<li>为什么需要条件变量？</li>
</ul>
<p>假设某个功能需要等待某个条件成立才能执行，如果没有条件变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span>(条件满足)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">doSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">程序会一直轮询，重复加锁，解锁，极大的浪费了系统资源</span><br></pre></td></tr></table></figure>

<p><strong>条件变量的引入，使多个线程以一种无竞争的方式等待条件的改变。</strong></p>
<p><strong>为什么条件变量需要和互斥锁搭配使用？</strong></p>
<ul>
<li>既然条件变量自身会阻塞，那么为什么又要再配合互斥锁呢？</li>
</ul>
<p>首先把目光聚焦到pthread_cond_wait的执行步骤上，<strong>pthread_cond_wait是不进行条件判断的！所以需要在pthread_cond_wait前判断条件</strong>，首先它会对互斥锁解锁然后阻塞当前线程，<strong>并将当前线程加入条件信号的等待队列cond_wait队列</strong>，最后当条件完成时重新加锁退出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">while</span>(cond)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="built_in">unlock</span>(); <span class="comment">//在进入wait前解锁。</span></span><br><span class="line">	<span class="built_in">pthread_cond_wait</span>(conda);  <span class="comment">//它会重新加锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line"><span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>在wait前解锁模拟不加锁的情况：当线程A在unlock（）还未执行到wait（）时线程B拿到了锁，并改变了条件发出信号。这是线程A还未执行到wait（），线程A错过了这次信号，可能会永远阻塞下去！</p>
<p>所以加锁一是为了防止对条件变量的竞争条件，二是保证cond_wait的操作是原子性的，不会出错！</p>
<p><strong>对条件的判断请用循环</strong></p>
<p>因为cond_signal可能造成虚假唤醒：</p>
<ul>
<li>虚假唤醒：指的是即便我们<strong>没有 signal 相关的条件变量</strong>(即没有调用 pthread_cond_signal), 等待(调用了 pthread_cond_wait)的<strong>线程也可能被(虚假)唤醒</strong>,（ <strong>即使没有线程**broadcast 或者signal条件变量，**wait也可能偶尔返回。这是多核处理器底层实现的问题**）此时我们必须</strong>重新检查对应的标记值**(以确认是否发生了(虚假)唤醒),又由于(虚假)唤醒可能会发生多次,所以我们最终需要使用循环来进行标记值检查.</li>
</ul>
<p>因为在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。结果是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>不建议使用</p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>back_end</tag>
      </tags>
  </entry>
  <entry>
    <title>毒药（高兴译）</title>
    <url>/2021/12/19/hello-world/</url>
    <content><![CDATA[<p>————-索列斯库</p>
<p>青草、山峦、河流和天空</p>
<p>纷纷走进我的血液，</p>
<p>此刻，我正等待着它们</p>
<p>药性发作。</p>
<p>由于青草，</p>
<p>我觉得全身开始葱笼。</p>
<p>由于山峦，</p>
<p>我的心充满了深渊</p>
<p>和雾霭。</p>
<p>由于河流，</p>
<p>我的双足磨圆了</p>
<p>路上的每一颗石子，</p>
<p>依然在打听大海的下落。</p>
<p>我感到</p>
<p>自己仿佛变得蔚蓝，变得无边无际，</p>
<p>眼睛和指尖上</p>
<p>栖息着无数的星辰。</p>
]]></content>
  </entry>
  <entry>
    <title>auto</title>
    <url>/2021/12/21/%E5%85%B3%E4%BA%8Eauto/</url>
    <content><![CDATA[<p>这几天leetcode刷题时发现auto遍历比for(i;)遍历快上不少（其实很早就有疑惑了），我个人猜测是因为for(auto )相当于迭代器，相较于a[i] 少了一次查找。顺便记一记auto遇到/看到的坑</p>
 <span id="more"></span>

<h4 id="auto-和-const-auto-amp"><a href="#auto-和-const-auto-amp" class="headerlink" title="auto 和 const auto&amp;"></a>auto 和 const auto&amp;</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;.....&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = vec[<span class="number">0</span>]; <span class="comment">// 创建一份 vec[0] 的拷贝。对s1改变不会影响vec</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = vec[<span class="number">0</span>]; <span class="comment">// s2 是 vec[0] 的一个引用。不会拷贝也不会影响vec.</span></span><br><span class="line"><span class="keyword">auto</span>&amp; s3=vec[<span class="number">0</span>]; <span class="comment">//对s3操作会影响vec[0]，不能定义临时对象</span></span><br><span class="line"><span class="comment">/*Effective Modern C++ 第一章:</span></span><br><span class="line"><span class="comment">当被左值初始化时，auto&amp;&amp;是左值引用(l-value reference)</span></span><br><span class="line"><span class="comment">当被右值初始化时，auto&amp;&amp;是右值引用(r-value reference)</span></span><br><span class="line"><span class="comment">那么，当vector&lt;bool&gt;返回的是临时对象，即右值时，我们也能正确的使用右值引用捕获住。*/</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; s4=vec[<span class="number">0</span>]; <span class="comment">//同上，但可以定义临时对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s5=vec[<span class="number">0</span>]; <span class="comment">//拷贝，但不修改它的值</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">处理不含有proxy <span class="class"><span class="keyword">class</span> <span class="title">reference</span>的<span class="title">range</span>时，<span class="title">for</span>(<span class="title">auto</span> &amp; <span class="title">x</span> :</span> range)</span><br><span class="line">含有proxy <span class="class"><span class="keyword">class</span> <span class="title">reference</span>时的<span class="title">range</span>时，<span class="title">for</span>(<span class="title">auto</span> &amp;&amp; <span class="title">x</span> :</span> range)</span><br><span class="line">只读时用 <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : range)</span><br></pre></td></tr></table></figure>



<h4 id="auto遇到Proxy-Class"><a href="#auto遇到Proxy-Class" class="headerlink" title="auto遇到Proxy Class"></a>auto遇到Proxy Class</h4><p>代理类(proxy class),指的是”它的每一个对象都是为了其他对象而存在的,就像是其他对象的代理人一般”.某些情况下用代理类取代某些内置类型可以实现独特的功能,因为可以为代理类定义成员函数而但却无法对内置类型定义操作.</p>
<p>简而言之proxy class就是在一个class中，嵌套的声明了另一个class，利用了这个隐藏的嵌套class以实现一些特殊技巧。</p>
<p>例：vector<bool> 返回的不是bool而是一个用于引用bool的代理类！平时使用，这个类会有一个隐式转换，所以看起来和用一个bool没什么差别，但是当你auto时，得到的并不是bool而是bool的代理类！如果你想auto它，那你得先static_cast<bool> 强转，再使用auto。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏服务器开发之路1</title>
    <url>/2021/12/21/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF1/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>

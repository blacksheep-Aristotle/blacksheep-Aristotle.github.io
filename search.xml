<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>毒药（高兴译）</title>
    <url>/2021/12/19/hello-world/</url>
    <content><![CDATA[<p>————-索列斯库</p>
<p>青草、山峦、河流和天空</p>
<p>纷纷走进我的血液，</p>
<p>此刻，我正等待着它们</p>
<p>药性发作。</p>
<p>由于青草，</p>
<p>我觉得全身开始葱笼。</p>
<p>由于山峦，</p>
<p>我的心充满了深渊</p>
<p>和雾霭。</p>
<p>由于河流，</p>
<p>我的双足磨圆了</p>
<p>路上的每一颗石子，</p>
<p>依然在打听大海的下落。</p>
<p>我感到</p>
<p>自己仿佛变得蔚蓝，变得无边无际，</p>
<p>眼睛和指尖上</p>
<p>栖息着无数的星辰。</p>
]]></content>
  </entry>
  <entry>
    <title>游戏服务器开发之路1</title>
    <url>/2021/12/21/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>L-value and R-value</title>
    <url>/2021/12/21/L-value-and-R-value/</url>
    <content><![CDATA[<h1 id="什么是左值和右值"><a href="#什么是左值和右值" class="headerlink" title="什么是左值和右值"></a>什么是左值和右值</h1><p>c++ primer plus：</p>
<p>变量和文字常量都有存储区，并且有相关的类型。区别在于变量是可寻址的（addressable）对于每一个变量都有两个值与其相联：</p>
<p>   1).它的数据值，存储在某个内存地址中。有时这个值也被称为对象的右值（rvalue,读做are-value）.我们也可认为右值的意思是被读取的值（read   value）。   文字常量和变量都可  被用作右值。   </p>
<p>   2).它的地址值——即存储数据值的那块内存的地址。它有时被称为变量的左值（lvalue，读作ell-value）。我们也可认为左值的意思是位置值location   value文字常量不能被用作左值。</p>
<p>简单来说左值就是存放在内存单元中（data段，roadata段。。。）的值，有实际存储地址，可以&amp;取地址的？</p>
<p>右值则不是内存单元中的值，不能对它&amp;取地址，可能存储在寄存器中，也可能是立即数或一个临时对象？</p>
 <span id="more"></span>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>auto</title>
    <url>/2021/12/21/%E5%85%B3%E4%BA%8Eauto/</url>
    <content><![CDATA[<p>这几天leetcode刷题时发现auto遍历比for(i;)遍历快上不少（其实很早就有疑惑了），我个人猜测是因为for(auto )相当于迭代器，相较于a[i] 少了一次查找。顺便记一记auto遇到/看到的坑</p>
 <span id="more"></span>

<h4 id="auto-和-const-auto-amp"><a href="#auto-和-const-auto-amp" class="headerlink" title="auto 和 const auto&amp;"></a>auto 和 const auto&amp;</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;.....&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = vec[<span class="number">0</span>]; <span class="comment">// 创建一份 vec[0] 的拷贝。对s1改变不会影响vec</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = vec[<span class="number">0</span>]; <span class="comment">// s2 是 vec[0] 的一个引用。不会拷贝也不会影响vec.</span></span><br><span class="line"><span class="keyword">auto</span>&amp; s3=vec[<span class="number">0</span>]; <span class="comment">//对s3操作会影响vec[0]，不能定义临时对象</span></span><br><span class="line"><span class="comment">/*Effective Modern C++ 第一章:</span></span><br><span class="line"><span class="comment">当被左值初始化时，auto&amp;&amp;是左值引用(l-value reference)</span></span><br><span class="line"><span class="comment">当被右值初始化时，auto&amp;&amp;是右值引用(r-value reference)</span></span><br><span class="line"><span class="comment">那么，当vector&lt;bool&gt;返回的是临时对象，即右值时，我们也能正确的使用右值引用捕获住。*/</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; s4=vec[<span class="number">0</span>]; <span class="comment">//同上，但可以定义临时对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> s5=vec[<span class="number">0</span>]; <span class="comment">//拷贝，但不修改它的值</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">处理不含有proxy <span class="class"><span class="keyword">class</span> <span class="title">reference</span>的<span class="title">range</span>时，<span class="title">for</span>(<span class="title">auto</span> &amp; <span class="title">x</span> :</span> range)</span><br><span class="line">含有proxy <span class="class"><span class="keyword">class</span> <span class="title">reference</span>时的<span class="title">range</span>时，<span class="title">for</span>(<span class="title">auto</span> &amp;&amp; <span class="title">x</span> :</span> range)</span><br><span class="line">只读时用 <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : range)</span><br></pre></td></tr></table></figure>



<h4 id="auto遇到Proxy-Class"><a href="#auto遇到Proxy-Class" class="headerlink" title="auto遇到Proxy Class"></a>auto遇到Proxy Class</h4><p>代理类(proxy class),指的是”它的每一个对象都是为了其他对象而存在的,就像是其他对象的代理人一般”.某些情况下用代理类取代某些内置类型可以实现独特的功能,因为可以为代理类定义成员函数而但却无法对内置类型定义操作.</p>
<p>简而言之proxy class就是在一个class中，嵌套的声明了另一个class，利用了这个隐藏的嵌套class以实现一些特殊技巧。</p>
<p>例：vector<bool> 返回的不是bool而是一个用于引用bool的代理类！平时使用，这个类会有一个隐式转换，所以看起来和用一个bool没什么差别，但是当你auto时，得到的并不是bool而是bool的代理类！如果你想auto它，那你得先static_cast<bool> 强转，再使用auto。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存</title>
    <url>/2021/12/20/c-%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>interior</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++多线程简要</title>
    <url>/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/</url>
    <content><![CDATA[<p>读muduo总结（本文许多例子引用自Linux多线程服务端编程），推荐方向是linux或后端的同学读一读此书）</p>
<h1 id="多线程下的对象安全"><a href="#多线程下的对象安全" class="headerlink" title="多线程下的对象安全"></a>多线程下的对象安全</h1><p>因为c++中要求程序员自己管理对象的生命周期，而在多线程环境下，一个对象可能被多个线程看到/操作，如何保证对象的安全显得尤为困难。</p>
<p>即如何保证对象的安全性，顺序性，存在性</p>
 <span id="more"></span>

<ul>
<li>如何保证不会因为交叉的操作而造成死锁？</li>
</ul>
<p>例：</p>
<ul>
<li>如何保证对象的操作是符合设定顺序的：a++ a– 不会执行成a– a++</li>
</ul>
<ul>
<li>如何保证操作的对象是存在的？如何保证销毁对象时对象不会被其他线程引用？</li>
</ul>
<p>这里引用陈硕的例子：</p>
<p>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行 该对象的成员函数？ </p>
<p>如何保证在执行成员函数期间，对象不会在另一个线程被析构？ </p>
<p>在调用某个对象的成员函数之前，如何得知这个对象还活着？它 的析构函数会不会碰巧执行到一半？</p>
<p>所以当你在多线程环境中编写对象时，请在下手时多思考思考：我怎么保证对象的安全性，顺序性，存在性？</p>
<p><strong>依据[JCP]，一个线程安全的class应当满足以下三个条件：</strong> </p>
<ul>
<li>多个线程同时访问时，其表现出正确的行为。 </li>
<li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何 交织（interleaving）。 </li>
<li>调用端代码无须额外的同步或其他协调动作。</li>
</ul>
<p><strong>c++标准库中的线程安全</strong></p>
<p>以下线程安全规则应用到标准 C++ 库中的所有类，这也包括 <code>shared_ptr</code>，如下所述。 有时提供更强的保证（例如，如下所述的标准 iostream 对象）和用于多线程的类型，如中所述<atomic>。</p>
<ul>
<li><p>从多个线程读取某个对象时，该对象是线程安全的。 例如，给定对象 A，可安全地同时从线程 1 和线程 2 读取 A。</p>
</li>
<li><p>如果要通过某个线程写入到对象，则必须保护相同线程或其他线程上所有对该对象的读取和写入。 例如，给定对象 A，如果线程 1 将写入到 A，则必须阻止线程 2 读取或写入 A。</p>
</li>
<li><p>即使另一个线程正在读取或写入同一类型的不同实例，也可以安全地读取和写入某个类型的实例。 例如，如果给定的对象 A 和 B 属于同一类型，则在线程1中写入时是安全的，并且在线程2中读取 B。</p>
</li>
</ul>
<h2 id="在对象构造时保证存在性"><a href="#在对象构造时保证存在性" class="headerlink" title="在对象构造时保证存在性"></a>在对象构造时保证存在性</h2><p>对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this 指针，即 </p>
<ul>
<li>不要在构造函数中注册任何回调； </li>
<li>也不要在构造函数中把this传给跨线程的对象； </li>
<li>即便在构造函数的最后一行也不行。</li>
</ul>
<p>之所以这样规定，是因为在构造函数执行期间对象还没有完成初始 化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除 外），那么别的线程有可能访问这个半成品对象。（对象的存在性无法保证）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">Foo</span>();  <span class="comment">//尽量不要在构造函数里出现this和回调函数，当需要注册回调函数时可以再定义一个函数用来实现所需功能</span></span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">observer</span><span class="params">(Observable* s)</span></span>&#123;</span><br><span class="line">		s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo* foo =<span class="keyword">new</span> Foo;</span><br><span class="line">Observable* s=<span class="built_in">getSubject</span>();</span><br><span class="line">foo-&gt;<span class="built_in">register_</span>(s);<span class="comment">// 二段式构造</span></span><br></pre></td></tr></table></figure>



<h2 id="析构对象时的线程安全"><a href="#析构对象时的线程安全" class="headerlink" title="析构对象时的线程安全"></a>析构对象时的线程安全</h2><p>在析构对象时保证线程安全，那用互斥锁不就好了吗？要销毁的时候加锁，然后析构，这样只有一个线程在析构，且其他线程现在无法访问这个对象，不就保证了对象的存在性和安全性了吗？</p>
<p><strong>但是用互斥锁来保证安全，那其成员函数用来保护临界区的互斥器本身就必须是有效的。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉！！！！</strong></p>
<p><img src="image-20211220205140600.png"></p>
<p>尽管线程A在销毁对象之后把指针置为了NULL，尽管线程B在调用x的 成员函数之前检查了指针x的值，但还是无法避免一种race condition： </p>
<p>1．线程A执行到了析构函数的(1)处，已经持有了互斥锁，即将继 续往下执行。 2．线程B通过了if (x)检测，阻塞在(2)处。</p>
<p>接下来会发生什么，只有天晓得。因为析构函数会把mutex_销毁， 那么(2)处有可能永远阻塞下去，有可能进入“临界区”，然后core dump，或者发生其他更糟糕的情况。 这个例子至少说明delete对象之后把指针置为NULL根本没用，如果 一个程序要靠这个来防止二次释放，说明代码逻辑出了问题。</p>
<p>这是可能有人会说了：既然互斥锁无法保证存在性，那我在操作对象的时候判断对象是否存在不就解决问题了吗？</p>
<p>很好，现在我们用指针来指向对象，用指针来判断对象是否存在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo *f=f1;</span><br><span class="line"><span class="keyword">if</span>(f)&#123;	<span class="comment">//存在？</span></span><br><span class="line">	f-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，用指针真的能判断对象是否存在吗？<strong>在Java中，一个reference只要不为null，它一定指向有效的对象。但是在c++中要知道，指针就只是指向了块内存而已，如果内存上的对象销毁了，你根本就访问不了它！</strong>直接erro了，更何况万一原址又创建了一个新的对象呢？再万一这个新的对象的类型 异于老的对象呢？</p>
<h2 id="用智能指针来解决存在性"><a href="#用智能指针来解决存在性" class="headerlink" title="用智能指针来解决存在性"></a>用智能指针来解决存在性</h2><p>**tips:**虽然智能指针好处很多，但设计绝大部分API的时候不应该出现智能指针，因为绝大多数API都不是操作所有权的API，而只是解引用访问被指向的对象，这时候正确的方式是使用裸指针裸引用，明确“无所有权”语义。</p>
<p><strong>shared_ptr控制对象的生命期。</strong>shared_ptr是<strong>强引用</strong>（想象成用铁丝 绑住堆上的对象），只要有一个指向x对象的shared_ptr存在，该x对象 就不会析构。当指向对象x的<strong>最后一个shared_ptr析构</strong>或reset()的时候，x 保证会被销毁。</p>
<p>std::shared_ptr 其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。（注意boost::bind 和容器的拷贝shared_ptr都有可能使引用值+1。）</p>
<p><strong>std::weak_ptr 要与 std::shared_ptr 一起使用。</strong> 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p>
<ol>
<li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li>
<li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li>
</ol>
<h3 id="智能指针的好处"><a href="#智能指针的好处" class="headerlink" title="智能指针的好处"></a>智能指针的好处</h3><ul>
<li>1．缓冲区溢出：用std::vector/std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是 裸指针来修改缓冲区。 </li>
<li>2．空悬指针／野指针：用shared_ptr/weak_ptr。 </li>
<li>3．重复释放：用scoped_ptr，只在对象析构的时候释放一次。 </li>
<li>4．内存泄漏：用scoped_ptr，对象析构的时候自动释放内存。 </li>
<li>5．不配对的new[]/delete：把new[]统统替换为 std::vector/scoped_array。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span>  // <span class="title">not</span> 100% <span class="title">thread</span> <span class="title">safe</span>!</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(weak_ptr&lt;Observer&gt; x)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(weak_ptr&lt;Observer&gt; x)</span></span>;  <span class="comment">// 可用 std::remove/vector::erase 实现</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator it = observers_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it != observers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="function">shared_ptr&lt;Observer&gt; <span class="title">obj</span><span class="params">(it-&gt;lock())</span></span>;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用次数+1</span></span><br><span class="line"></span><br><span class="line">        obj-&gt;<span class="built_in">update</span>();  <span class="comment">// 没有竞态条件，因为 obj 在栈上，对象不可能在本作用域内销毁</span></span><br><span class="line"></span><br><span class="line">        ++it;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象已经销毁，从容器中拿掉 weak_ptr</span></span><br><span class="line"></span><br><span class="line">        it = observers_.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  std::vector&lt;weak_ptr&lt;Observer&gt; &gt; observers_;  <span class="comment">// 如果把weak换成shared那Observer的生命周期会被延长，直至Observable析构或者调用unregister，因为容器的拷贝也会使引用值+1！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> Mutex mutex_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>尽量使一个对象只能被一个线程看见和操作，这样对象的构造和析构都在一个线程内完成，多线程下的对象安全就变成了单线程下的对象安全，任务简单不少。</p>
<p>如果真要使一个对象被多个线程操作，请使用智能指针来保证对象的存在性，且对象的构造和析构尽量由相同线程执行。在使用锁的时候尽量缩短临界区来提高安全性。</p>
<h2 id="如何保证对象的安全性"><a href="#如何保证对象的安全性" class="headerlink" title="如何保证对象的安全性"></a>如何保证对象的安全性</h2><p>待更</p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>back_end</tag>
      </tags>
  </entry>
</search>

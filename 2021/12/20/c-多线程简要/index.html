<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aristotle-plato.xyz","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="读muduo总结（本文许多例子引用自Linux多线程服务端编程），推荐方向是linux或后端的同学读一读此书） 多线程下的对象安全因为c++中要求程序员自己管理对象的生命周期，而在多线程环境下，一个对象可能被多个线程看到&#x2F;操作，如何保证对象的安全显得尤为困难。 即如何保证对象的安全性，顺序性，存在性">
<meta property="og:type" content="article">
<meta property="og:title" content="c++多线程简要">
<meta property="og:url" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/index.html">
<meta property="og:site_name" content="MR.Z">
<meta property="og:description" content="读muduo总结（本文许多例子引用自Linux多线程服务端编程），推荐方向是linux或后端的同学读一读此书） 多线程下的对象安全因为c++中要求程序员自己管理对象的生命周期，而在多线程环境下，一个对象可能被多个线程看到&#x2F;操作，如何保证对象的安全显得尤为困难。 即如何保证对象的安全性，顺序性，存在性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211220205140600.png">
<meta property="og:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222211943772.png">
<meta property="og:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222164757247.png">
<meta property="og:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222165207047.png">
<meta property="og:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222170900205.png">
<meta property="og:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222202030478.png">
<meta property="article:published_time" content="2021-12-20T10:08:10.000Z">
<meta property="article:modified_time" content="2021-12-22T13:43:18.674Z">
<meta property="article:author" content="张二">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="back_end">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211220205140600.png">

<link rel="canonical" href="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>c++多线程简要 | MR.Z</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="MR.Z" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MR.Z</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张二">
      <meta itemprop="description" content="我心碎，并不为那些被我们丢下的，而是为那些我们原本可以，却未曾着手建造的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MR.Z">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++多线程简要
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-20 18:08:10" itemprop="dateCreated datePublished" datetime="2021-12-20T18:08:10+08:00">2021-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 21:43:18" itemprop="dateModified" datetime="2021-12-22T21:43:18+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index"><span itemprop="name">server</span></a>
                </span>
            </span>

          

<span title="post.wordcount">
    5.3k 字
</span>

<span title="post.min2read">
    20 分钟
</span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>读muduo总结（本文许多例子引用自Linux多线程服务端编程），推荐方向是linux或后端的同学读一读此书）</p>
<h1 id="多线程下的对象安全"><a href="#多线程下的对象安全" class="headerlink" title="多线程下的对象安全"></a>多线程下的对象安全</h1><p>因为c++中要求程序员自己管理对象的生命周期，而在多线程环境下，一个对象可能被多个线程看到/操作，如何保证对象的安全显得尤为困难。</p>
<p>即如何保证对象的安全性，顺序性，存在性</p>
 <span id="more"></span>

<ul>
<li>如何保证不会因为交叉的操作而造成死锁？</li>
</ul>
<p>例：</p>
<ul>
<li>如何保证对象的操作是符合设定顺序的：a++ a– 不会执行成a– a++</li>
</ul>
<ul>
<li>如何保证操作的对象是存在的？如何保证销毁对象时对象不会被其他线程引用？</li>
</ul>
<p>这里引用陈硕的例子：</p>
<p>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行 该对象的成员函数？ </p>
<p>如何保证在执行成员函数期间，对象不会在另一个线程被析构？ </p>
<p>在调用某个对象的成员函数之前，如何得知这个对象还活着？它 的析构函数会不会碰巧执行到一半？</p>
<p>所以当你在多线程环境中编写对象时，请在下手时多思考思考：我怎么保证对象的安全性，顺序性，存在性？</p>
<p><strong>依据[JCP]，一个线程安全的class应当满足以下三个条件：</strong> </p>
<ul>
<li>多个线程同时访问时，其表现出正确的行为。 </li>
<li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何 交织（interleaving）。 </li>
<li>调用端代码无须额外的同步或其他协调动作。</li>
</ul>
<p><strong>c++标准库中的线程安全</strong></p>
<p>以下线程安全规则应用到标准 C++ 库中的所有类，这也包括 <code>shared_ptr</code>，如下所述。 有时提供更强的保证（例如，如下所述的标准 iostream 对象）和用于多线程的类型，如中所述<atomic>。</p>
<ul>
<li><p>从多个线程读取某个对象时，该对象是线程安全的。 例如，给定对象 A，可安全地同时从线程 1 和线程 2 读取 A。</p>
</li>
<li><p>如果要通过某个线程写入到对象，则必须保护相同线程或其他线程上所有对该对象的读取和写入。 例如，给定对象 A，如果线程 1 将写入到 A，则必须阻止线程 2 读取或写入 A。</p>
</li>
<li><p>即使另一个线程正在读取或写入同一类型的不同实例，也可以安全地读取和写入某个类型的实例。 例如，如果给定的对象 A 和 B 属于同一类型，则在线程1中写入时是安全的，并且在线程2中读取 B。</p>
</li>
</ul>
<h2 id="在对象构造时保证存在性"><a href="#在对象构造时保证存在性" class="headerlink" title="在对象构造时保证存在性"></a>在对象构造时保证存在性</h2><p>对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this 指针，即 </p>
<ul>
<li>不要在构造函数中注册任何回调； </li>
<li>也不要在构造函数中把this传给跨线程的对象； </li>
<li>即便在构造函数的最后一行也不行。</li>
</ul>
<p>之所以这样规定，是因为在构造函数执行期间对象还没有完成初始 化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除 外），那么别的线程有可能访问这个半成品对象。（对象的存在性无法保证）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">Foo</span>();  <span class="comment">//尽量不要在构造函数里出现this和回调函数，当需要注册回调函数时可以再定义一个函数用来实现所需功能</span></span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">observer</span><span class="params">(Observable* s)</span></span>&#123;</span><br><span class="line">		s-&gt;<span class="built_in">register_</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo* foo =<span class="keyword">new</span> Foo;</span><br><span class="line">Observable* s=<span class="built_in">getSubject</span>();</span><br><span class="line">foo-&gt;<span class="built_in">register_</span>(s);<span class="comment">// 二段式构造</span></span><br></pre></td></tr></table></figure>



<h3 id="析构对象时的线程安全"><a href="#析构对象时的线程安全" class="headerlink" title="析构对象时的线程安全"></a>析构对象时的线程安全</h3><p>在析构对象时保证线程安全，那用互斥锁不就好了吗？要销毁的时候加锁，然后析构，这样只有一个线程在析构，且其他线程现在无法访问这个对象，不就保证了对象的存在性和安全性了吗？</p>
<p><strong>但是用互斥锁来保证安全，那其成员函数用来保护临界区的互斥器本身就必须是有效的。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉！！！！</strong></p>
<p><img src="image-20211220205140600.png"></p>
<p>尽管线程A在销毁对象之后把指针置为了NULL，尽管线程B在调用x的 成员函数之前检查了指针x的值，但还是无法避免一种race condition： </p>
<p>1．线程A执行到了析构函数的(1)处，已经持有了互斥锁，即将继 续往下执行。 2．线程B通过了if (x)检测，阻塞在(2)处。</p>
<p>接下来会发生什么，只有天晓得。因为析构函数会把mutex_销毁， 那么(2)处有可能永远阻塞下去，有可能进入“临界区”，然后core dump，或者发生其他更糟糕的情况。 这个例子至少说明delete对象之后把指针置为NULL根本没用，如果 一个程序要靠这个来防止二次释放，说明代码逻辑出了问题。</p>
<p>这是可能有人会说了：既然互斥锁无法保证存在性，那我在操作对象的时候判断对象是否存在不就解决问题了吗？</p>
<p>很好，现在我们用指针来指向对象，用指针来判断对象是否存在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo *f=f1;</span><br><span class="line"><span class="keyword">if</span>(f)&#123;	<span class="comment">//存在？</span></span><br><span class="line">	f-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，用指针真的能判断对象是否存在吗？<strong>在Java中，一个reference只要不为null，它一定指向有效的对象。但是在c++中要知道，指针就只是指向了块内存而已，如果内存上的对象销毁了，你根本就访问不了它！</strong>直接erro了，更何况万一原址又创建了一个新的对象呢？再万一这个新的对象的类型 异于老的对象呢？</p>
<h3 id="用智能指针来解决存在性"><a href="#用智能指针来解决存在性" class="headerlink" title="用智能指针来解决存在性"></a>用智能指针来解决存在性</h3><p>**tips:**虽然智能指针好处很多，但设计绝大部分API的时候不应该出现智能指针，因为绝大多数API都不是操作所有权的API，而只是解引用访问被指向的对象，这时候正确的方式是使用裸指针裸引用，明确“无所有权”语义。</p>
<p><strong>shared_ptr控制对象的生命期。</strong>shared_ptr是<strong>强引用</strong>（想象成用铁丝 绑住堆上的对象），只要有一个指向x对象的shared_ptr存在，该x对象 就不会析构。当指向对象x的<strong>最后一个shared_ptr析构</strong>或reset()的时候，x 保证会被销毁。</p>
<p>std::shared_ptr 其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。（注意boost::bind 和容器的拷贝shared_ptr都有可能使引用值+1。）</p>
<p><strong>std::weak_ptr 要与 std::shared_ptr 一起使用。</strong> 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p>
<ol>
<li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li>
<li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li>
</ol>
<h4 id="智能指针的好处"><a href="#智能指针的好处" class="headerlink" title="智能指针的好处"></a>智能指针的好处</h4><ul>
<li>1．缓冲区溢出：用std::vector/std::string或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是 裸指针来修改缓冲区。 </li>
<li>2．空悬指针／野指针：用shared_ptr/weak_ptr。 </li>
<li>3．重复释放：用scoped_ptr，只在对象析构的时候释放一次。 </li>
<li>4．内存泄漏：用scoped_ptr，对象析构的时候自动释放内存。 </li>
<li>5．不配对的new[]/delete：把new[]统统替换为 std::vector/scoped_array。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span>  // <span class="title">not</span> 100% <span class="title">thread</span> <span class="title">safe</span>!</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(weak_ptr&lt;Observer&gt; x)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(weak_ptr&lt;Observer&gt; x)</span></span>;  <span class="comment">// 可用 std::remove/vector::erase 实现</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    Iterator it = observers_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it != observers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="function">shared_ptr&lt;Observer&gt; <span class="title">obj</span><span class="params">(it-&gt;lock())</span></span>;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (obj) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用次数+1</span></span><br><span class="line"></span><br><span class="line">        obj-&gt;<span class="built_in">update</span>();  <span class="comment">// 没有竞态条件，因为 obj 在栈上，对象不可能在本作用域内销毁</span></span><br><span class="line"></span><br><span class="line">        ++it;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象已经销毁，从容器中拿掉 weak_ptr</span></span><br><span class="line"></span><br><span class="line">        it = observers_.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  std::vector&lt;weak_ptr&lt;Observer&gt; &gt; observers_;  <span class="comment">// 如果把weak换成shared那Observer的生命周期会被延长，直至Observable析构或者调用unregister，因为容器的拷贝也会使引用值+1！</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> Mutex mutex_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>尽量使一个对象只能被一个线程看见和操作，这样对象的构造和析构都在一个线程内完成，多线程下的对象安全就变成了单线程下的对象安全，任务简单不少。</p>
<p>如果真要使一个对象被多个线程操作，请使用智能指针来保证对象的存在性，且对象的构造和析构尽量由相同线程执行。在使用锁的时候尽量缩短临界区来提高安全性。</p>
<h2 id="如何保证对象的安全性与顺序性"><a href="#如何保证对象的安全性与顺序性" class="headerlink" title="如何保证对象的安全性与顺序性"></a>如何保证对象的安全性与顺序性</h2><p>前言</p>
<p><strong>产生死锁的四个必要条件：</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p><strong>线程使用注意事项和线程安全（可重入函数）</strong></p>
<ul>
<li>1．首要原则是尽量最低限度地共享对象，减少需要同步的场合。 一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑 immutable对象；实在不行才暴露可修改的对象，并用同步措施来充分 保护它。</li>
<li>2．其次是使用高级的并发编程构件，如TaskQueue、ProducerConsumer Queue、CountDownLatch等等。 </li>
<li>3．最后不得已必须使用底层同步原语（primitives）时，只用非递 归的互斥器和条件变量，慎用读写锁，不要用信号量。 </li>
<li>4．除了使用atomic整数之外，不自己编写lock-free代码，也不要 用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs. mutex。</li>
</ul>
<p>​                                                                    ——————————陈硕</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><strong>什么是锁？</strong></p>
<p><strong>为什么一个线程拿到了锁，另一个线程企图去对这个锁进行Lock操作时，为什么会阻塞？</strong> </p>
<p><strong>锁，其实就是一个标志，0表示解锁1表示加锁，锁争用就是多个线程争着把标志变成1，当一个标志为1其他线程会自旋的访问它直到变成0再根据某种调度策略把标志的修改权限赋予某个线程。</strong></p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222211943772.png" alt="image-20211222211943772"></p>
<p>虽然这部分操作是原子的，但是如果多个线程一直自旋访问标志无疑会造成极大的资源浪费。如果线程进行这种比较和交换并且它失败了，它不会再旋转，而是进入睡眠状态，并在标志的值发生变化时恢复它，再开始自旋，重复上面的过程直到它获得了这个锁。</p>
<p><strong>Linux下就是用futex来实现上诉功能的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">We&#x27;re going to extend our flag variable to be able to take on another value, so, zero if tasks Q is free, one if it&#x27;s locked, and two if there is a thread waiting on the value of flag to change. Here in our reader, we do the atomic compare-and-swap. Assume it fails, here first we&#x27;re going to change flag to be two to indicate that the thread is going to sleep, and then we issue the futex system call to tell the kernel to put us to sleep, to suspend us, to tell the kernel, &quot;We want to be woken up once the value of flag changes.&quot; The kernel takes care of that part, and then once we&#x27;re resumed, we&#x27;re going to try and compare and swap again.</span><br><span class="line"></span><br><span class="line">Switching to kernel land, let&#x27;s see what the kernel does. The kernel needs to do two things. The first thing is, it needs to store away this information that we have T1 waiting on the flag variable so it can be resumed in the future. The way the Linux kernel does this is, we generate a key from the user space address - we need to do this because we&#x27;re in the kernel now. This is stored away in a wait queue entry that stores the thread and the key. If we had one wait queue per user space address, that sounds incredibly wasteful. What actually happens is - we use a hash table - the key is hashed, and we have a wait queue per hash bucket. What this means is, you can have two user space addresses that hash to the same hash bucket, and those entries would be stored in the same wait queue. Not a problem because the entries store the key as well.</span><br><span class="line"></span><br><span class="line">Now that we&#x27;ve stored away this information, to resume the thread later, we can put the thread to sleep. This is what the kernel does, it deschedules the calling thread. On the writer side, say the writer comes along, it finishes what it&#x27;s doing, it&#x27;s going to set the flag to unlocked, and then it&#x27;s going to issue a futex system call to tell the kernel to wake up a thread that was waiting on flag. The kernel does its thing, it finds the right hash bucket, it walks the wait queue, and it wakes up the first thread that was waiting on flag.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/go-locks/">————让我们来谈谈锁    go中轻量锁的实现！ (infoq.com)</a></p>
<p>简而言之，就是线程在用户态争抢一块内存（一个指定的变量），如果抢不到，就自旋n次，还是没抢到，调用futex_wait进入内核态，去把自己挂起+排队（跟这个锁相关的队列），等着被释放锁的线程futex_wake（从内核态转用户态）。</p>
<p><strong>回到问题：</strong></p>
<ul>
<li><strong>一个线程拿到了锁，另一个线程企图去对这个锁进行Lock操作时，为什么会阻塞？</strong> </li>
</ul>
<p>这里的阻塞其实就是睡眠了，当线程一直抢不到锁时，操作系统会让他强制休眠，直到锁被释放再将他唤醒。</p>
<p><strong>使用非递归的互斥锁，不使用读写锁。</strong></p>
<p>使用非递归的原因是非递归和递归的性能差别不大，但是非递归能帮助我们在发现erro后更方便的找到错误原因（想象一下这个画面，一个递归锁被多个线程反复调用最终发生了死锁，你要怎么找到是哪个线程哪一步造成的原因呢）。</p>
<p>如果使用非递归锁，那么<strong>一个线程</strong>不能对同一个锁重复加锁，否则立即发生死锁。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span>&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    f-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line">test中加了锁，但是print又加了锁，非递归锁不能被一个线程重复加锁，所以立刻造成了死锁</span><br></pre></td></tr></table></figure>

<p>如果并不清楚这个函数是否会在已加锁的情况下调用，有以下几个解决方法：</p>
<ul>
<li>使用Linux已封装的lock_gurad()</li>
</ul>
<p>lock_gurad（）是Linux已经封装好的RAII思想的lock（），会在创建的时候加锁，销毁的时候自动解锁。</p>
<p>lock_gurad（）有个参数std::adopt_lock，收养锁，adopt_guard为结构体对象，表明当前线程已经获得了锁，不需要再锁了，此后mutex对象的解锁操作交由 lock_guard 对象 guard 来管理，在 guard 的生命周期结束之后，mutex对象会自动解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">my_guard</span><span class="params">(my_mutex,std::adopt_lock)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span>&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">my_guard</span><span class="params">(my_mutex,std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    f-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：一般都是使用自己封装的lock_guard，并且lock_gurad（）锁的粒度可能很大，而且用adopt_lock的<strong>前提条件</strong>是要先给互斥量加锁，然后在后面的语句中不会再次lock()</p>
<ul>
<li>再创建一个相同的函数withlock用于加锁的场景，原来的函数用于不加锁的场景</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">f</span>&#123;</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printwithlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutex);</span><br><span class="line">    f-&gt;<span class="built_in">printwithlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重载函数，如果使用了锁，就用不加锁的那一个</li>
</ul>
<p><strong>还有一种常见的死锁场景是锁的交叉使用</strong></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap1</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">	<span class="built_in">lock</span>(mutexa);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">lock</span>(mutexb);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap2</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="built_in">lock</span>(mutexb);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">lock</span>(mutexa);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此时一个线程A执行swap1，另一个线程B执行swap2.</p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222164757247.png" alt="image-20211222164757247"></p>
<p>这两个线程因为永远等不到所需的锁，所以造成了死锁卡住了。一般来说多线程造成死锁的原因就是锁的交叉死锁，造成了你有我的锁，我有你的锁，成了个死循环。</p>
<p>这种死锁解决较为简单，因为调用顺序明了，不涉及内存的读写，只要养成在执行的时候按顺序加锁解锁的习惯就解决了。</p>
<p>这里再用陈硕的例子—–一个不易察觉的死锁：</p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222165207047.png" alt="image-20211222165207047"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::printall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">lockguard <span class="title">lock</span><span class="params">(Lmutex_)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f:requests_.<span class="built_in">end</span>())&#123;</span><br><span class="line">		f-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Request::print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">lockgurad <span class="title">lock</span><span class="params">(Rmutex_)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Request::process</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockgurad <span class="title">lock</span><span class="params">(Rmutex_)</span></span>;</span><br><span class="line">    inventory_.<span class="built_in">add</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::add</span><span class="params">(Request* req)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockgurad <span class="title">lock</span><span class="params">(Imutex_)</span></span>;</span><br><span class="line">    requests_.<span class="built_in">insert</span>(req);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Request</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">lockguard <span class="title">lock</span><span class="params">(Rmutex_)</span></span>;</span><br><span class="line">    inventory_.<span class="built_in">remove</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::remove</span><span class="params">(Request* req)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockguard <span class="title">lock</span><span class="params">(Lmutex_)</span></span>;</span><br><span class="line">    requests_.<span class="built_in">earse</span>(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看好像挺安全的，但是当req析构，inv刚好print（）刚加进去的req时：</p>
<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222170900205.png" alt="image-20211222170900205"></p>
<p><strong>！！死锁了，这就是经典的read-and-write死锁</strong></p>
<p>解决的方法就是copy-and-write：在副本上读，在副本上写！不直接对源成员改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::printall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Requestlist restcopy_;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">lockguard <span class="title">lock</span><span class="params">(Lmutex_)</span></span>;</span><br><span class="line">        restcopy_=requests_;	<span class="comment">//copy，复制副本</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f:restcopy_)&#123;		<span class="comment">//对副本读</span></span><br><span class="line">		f-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/image-20211222202030478.png" alt="image-20211222202030478"></p>
<p>因为锁L的临界区很短，可以说只与它自己有关，L的释放不再被其他锁约束。所以remove（）一定会获得锁L！也就不会造成死锁了。</p>
<p>但是这又引出了新的问题，一是深拷贝的开销太大，二是仍有可能执行一个不存在的print（）。为了改进这两点，给出第二种方法。</p>
<ul>
<li>使用智能指针管理restes_</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">set&lt;std::weak_ptr&lt;Request&gt; rptr&gt; requests_;  </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">set&lt;Request*&gt; requests;</span><br><span class="line">shared_ptr&lt;requests&gt; requests_ptr;</span><br><span class="line">requests_ptr requests_;</span><br><span class="line"><span class="comment">//以下给方法二的写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::printall</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requests_ptr req_ptrcopy;</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="function">lockgurad <span class="title">lock</span><span class="params">(Imutex_)</span></span>;</span><br><span class="line">        req_ptrcopy=requests_;   <span class="comment">//shared_ptr引用+1</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f:restcopy_)&#123;		<span class="comment">//对副本读</span></span><br><span class="line">		f-&gt;<span class="built_in">print</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::add</span><span class="params">(Request* req)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lockgurad <span class="title">lock</span><span class="params">(Imutex_)</span></span>;</span><br><span class="line">   	<span class="keyword">if</span>(!requests_.<span class="built_in">unique</span>())  <span class="comment">//对象正在被读</span></span><br><span class="line">    &#123;</span><br><span class="line">        requests_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">requests_ptr</span>(*requests_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(requests_.<span class="built_in">unique</span>());</span><br><span class="line">    requests_.<span class="built_in">insert</span>(req);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inventory::remove</span><span class="params">(Request* req)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">LockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!requests_.<span class="built_in">unique</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      requests_.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">requests_ptr</span>(*requests_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(requests_.<span class="built_in">unique</span>());</span><br><span class="line">    requests_-&gt;<span class="built_in">erase</span>(req);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<p>tips：不要同时读写，读/写前检查一下。<br>          不管读写，都要对shared_ptr加锁。<br>          写的copy一定要放在临界区内。<br>           写时，可以先加锁拷贝变量副本，然后修改变量副本。读时，可以先临界区拷贝变量到函数局部变量，再操作函数局部变量来避免死锁。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>使用信号量和条件变量来实现同步，注：对于wait端：条件变量得配合锁来使用。</p>
<ul>
<li>为什么需要条件变量？</li>
</ul>
<p>假设某个功能需要等待某个条件成立才能执行，如果没有条件变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span>(条件满足)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">doSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">程序会一直轮询，重复加锁，解锁，极大的浪费了系统资源</span><br></pre></td></tr></table></figure>

<p><strong>条件变量的引入，使多个线程以一种无竞争的方式等待条件的改变。</strong></p>
<p><strong>为什么条件变量需要和互斥锁搭配使用？</strong></p>
<ul>
<li>既然条件变量自身会阻塞，那么为什么又要再配合互斥锁呢？</li>
</ul>
<p>首先把目光聚焦到pthread_cond_wait的执行步骤上，<strong>pthread_cond_wait是不进行条件判断的！所以需要在pthread_cond_wait前判断条件</strong>，首先它会对互斥锁解锁然后阻塞当前线程，<strong>并将当前线程加入条件信号的等待队列cond_wait队列</strong>，最后当条件完成时重新加锁退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">while</span>(cond)</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="built_in">unlock</span>(); <span class="comment">//在进入wait前解锁。</span></span><br><span class="line">	<span class="built_in">pthread_cond_wait</span>(conda);  <span class="comment">//它会重新加锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">doSomething</span>();</span><br><span class="line"><span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p>在wait前解锁模拟不加锁的情况：当线程A在unlock（）还未执行到wait（）时线程B拿到了锁，并改变了条件发出信号。这是线程A还未执行到wait（），线程A错过了这次信号，可能会永远阻塞下去！</p>
<p>所以加锁一是为了防止对条件变量的竞争条件，二是保证cond_wait的操作是原子性的，不会出错！</p>
<p><strong>对条件的判断请用循环</strong></p>
<p>因为cond_signal可能造成虚假唤醒：</p>
<ul>
<li>虚假唤醒：指的是即便我们<strong>没有 signal 相关的条件变量</strong>(即没有调用 pthread_cond_signal), 等待(调用了 pthread_cond_wait)的<strong>线程也可能被(虚假)唤醒</strong>,（ <strong>即使没有线程**broadcast 或者signal条件变量，**wait也可能偶尔返回。这是多核处理器底层实现的问题**）此时我们必须</strong>重新检查对应的标记值**(以确认是否发生了(虚假)唤醒),又由于(虚假)唤醒可能会发生多次,所以我们最终需要使用循环来进行标记值检查.</li>
</ul>
<p>因为在多核处理器下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。结果是，当一个线程调用pthread_cond_signal()后，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>不建议使用</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>张二
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://aristotle-plato.xyz/2021/12/20/c-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E8%A6%81/" title="c++多线程简要">http://aristotle-plato.xyz/2021/12/20/c-多线程简要/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="wechat"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
              <a href="/tags/back-end/" rel="tag"># back_end</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/19/hello-world/" rel="prev" title="毒药（高兴译）">
      <i class="fa fa-chevron-left"></i> 毒药（高兴译）
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/20/c-%E5%86%85%E5%AD%98/" rel="next" title="c++内存">
      c++内存 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8"><span class="nav-number">1.</span> <span class="nav-text">多线程下的对象安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E6%97%B6%E4%BF%9D%E8%AF%81%E5%AD%98%E5%9C%A8%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">在对象构造时保证存在性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">析构对象时的线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%AD%98%E5%9C%A8%E6%80%A7"><span class="nav-number">1.1.2.</span> <span class="nav-text">用智能指针来解决存在性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">智能指针的好处</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">如何保证对象的安全性与顺序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">信号量</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">张二</p>
  <div class="site-description" itemprop="description">我心碎，并不为那些被我们丢下的，而是为那些我们原本可以，却未曾着手建造的</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

	<link rel="stylesheet" href="/dist/APlayer.min.css">
	<div id="aplayer"></div>
	<script type="text/javascript" src="/dist/APlayer.min.js"></script>
	<script type="text/javascript" src="/dist/music.js"></script>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张二</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":224,"height":224},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<script type="text/javascript" src="\js\FunnyTitle.js"></script>